#!/usr/bin/env python

"""mpistat_parse - parse the raw data generated by mpistat and produce a basic report"""

from __future__ import print_function

import re
import sys
import time
import grp
import pwd
import base64
import gzip
import csv
import argparse
from collections import namedtuple

cost_GBP_per_TiB_year = 150
filestats_field_names = ['volume', 'b64path', 'size', 'uid', 'gid', 'atime', 'mtime', 'ctime', 'type', 'inode', 'nlink', 'dev']

parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)

parser.add_argument("mpistat_data_file", help="Gzip-compressed output as produced by mpistat_tidy")
args = parser.parse_args()

def warning(*objs):
	"""Print a warning message to standard error"""
	print("WARNING: ", *objs, file=sys.stderr)

FileStats = namedtuple('FileStats', filestats_field_names)

class FileStatsIterable:
	def __init__(self, filename):
		csv.register_dialect('tsv', delimiter="\t", quoting=csv.QUOTE_NONE)
		self.gzfile = gzip.open(filename, "r")
		self.reader = csv.reader(self.gzfile, dialect='tsv')
	def next(self):
		row = self.reader.next()
		return FileStats._make(row)
	def close(self):
		return self.gzfile.close()
	def __iter__(self):
		return self

mpistat_iter = FileStatsIterable(args.mpistat_data_file)

by_group=dict()
by_user=dict()
by_user_group=dict()
file_types=dict()
now=time.time()
unprintable_files=[]
zero_length_files=dict()


# prepare user dict
uid2username = dict()
for pw in pwd.getpwall():
	uid2username[pw.pw_uid] = pw.pw_name

# prepare group dict
gid2group = dict()
for gr in grp.getgrall():
	gid2group[gr.gr_gid] = gr.gr_name

def getUser(uid) :
#	user=str(uid)
	return uid2username[uid]

def getGroup(gid) :
#	group=str(gid)
	return gid2group[gid]

def getAgeDays(epoch) :
	days=1.0*(now-epoch)/(24*60*60)
	if days < 0 :
		days=0
	return days

def getGiB(sz) :
	return sz/(1024.0*1024.0*1024.0)

def calculateCost(size, epoch):
	size_GiB = getGiB(size)
	age_days = getAgeDays(epoch)
	cost_per_GiB_day = cost_GBP_per_TiB_year/365/1024
	return size_GiB * age_days * cost_per_GiB_day

# if the filename contains non printable character,
# it will add it to the unprintable files list
# but will truncate it to just before the 1st unprintable character in the file
def check_filename(fname):
	count=0
	printable=True
	dodgy_chars=[]
	for c in fname :
		ascii=ord(c)
		if ascii < 32 or ascii > 126 :
			printable=False
			dodgy_chars.append(ascii)
		if printable :
			count += 1
	if not printable :
		unprintable_files.append((fname[:count],dodgy_chars))

###################################
# the big loop over all the files #
###################################
costs=[]
for filestat in mpistat_iter:
	filename = base64.b64decode(filestat.b64path)

	# check for filenames with dodgy characters
	check_filename(filename)

	# cast fields (TODO: necessary?)
	uid=int(filestat.uid)
	gid=int(filestat.gid)
	size=float(filestat.size)
	atime=float(filestat.atime)
	mtime=float(filestat.mtime)
	ctime=float(filestat.ctime)
	
	# lookup username and group
	username=getUser(uid)
	group=getGroup(gid)

	# calculate cost since creation, last modification, and last access
	cost_since_creation = calculateCost(size, ctime)
	cost_since_modification = calculateCost(size, mtime)
	cost_since_access = calculateCost(size, atime)
	
	# fixme hack to only pay attention to ctime cost
	cost = cost_since_creation
	if cost > 0 :
		costs.append(cost)
	if filestat.type in file_types :
		file_types[filestat.type]+=1
	else :
		file_types[filestat.type]=1
	if size == 0 :
		if filestat.type in zero_length_files :
			zero_length_files[filestat.type] += 1
		else :
			zero_length_files[filestat.type] = 1

	# by user stuff
	if uid in by_user :
		tmp=by_user[uid]
		tmp['total_cost']+=cost
		tmp['costs'].append(cost)
	else :
		tmp=dict()
		tmp['total_cost'] = cost
		tmp['costs']=[cost]
		by_user[uid]=tmp

	# by_group stuff
	if gid in by_group :
		tmp=by_group[gid]
		tmp['total_cost'] += cost
		tmp['costs'].append(cost)
	else :
		tmp=dict()
		tmp['total_cost'] = cost
		tmp['costs']=[cost]
		by_group[gid]=tmp

	# by_user_group stuff
	user_group=str(uid)+'_'+str(gid)
	if user_group in by_user_group :
		tmp=by_user_group[user_group]
		tmp['total_cost'] += cost
		tmp['costs'].append(cost)
	else :
		tmp=dict()
		tmp['total_cost'] = cost
		tmp['costs']=[cost]
		by_user_group[user_group]=tmp

# get the list of total cost per group
# and sort it then print it
by_group_list=[]
for g in by_group :
	tmp=dict()
	tmp['grp']  = getGroup(g)
	tmp['cost'] = by_group[g]['total_cost']
	tmp['gid']  = g
	by_group_list.append(tmp)
from operator import itemgetter
by_group_list = sorted(by_group_list, key=itemgetter('cost')) 
by_group_list.reverse()
print()
print("top 20 costly groups")
for d in by_group_list[:20] :
	print('%20s\t%10.2f' % (d['grp'],d['cost']))

# get the list of total cost per user
# and sort it then print it
by_user_list=[]
for u in by_user :
	tmp=dict()
	tmp['user']  = getUser(u)
	tmp['cost'] = by_user[u]['total_cost']
	tmp['uid']  = u
	by_user_list.append(tmp)
by_user_list = sorted(by_user_list, key=itemgetter('cost')) 
by_user_list.reverse()
print()
print("top 20 costly users")
for d in by_user_list[:20] :
	print('%20s\t%10.2f' % (d['user'],d['cost']))

# get the list of total cost per user / group
# and sort it then print it
by_user_group_list=[]
for ug in by_user_group :
	i=ug.find('_')
	u=int(ug[:i])
	g=int(ug[i+1:])
	tmp=dict()
	tmp['user']  = getUser(u)
	tmp['group'] = getGroup(g)
	tmp['cost'] = by_user_group[ug]['total_cost']
	tmp['uid']  = u
	tmp['gid']  = g
	by_user_group_list.append(tmp)
by_user_group_list = sorted(by_user_group_list, key=itemgetter('cost')) 
by_user_group_list.reverse()
print()
print("top 40 costly users breakdown by group")
for d in by_user_group_list[:40] :
	print('%20s\t%s\t%10.2f' % (d['user'],d['group'],d['cost']))

# print number of occurences of each file type
print()
print("number of inodes of each type")
print(file_types)

# zero length files
print()
print("Number of zero length inodes by type")
print(str(zero_length_files))

# unprintable files
print()
print("There are "+str(len(unprintable_files))+" unprintable files : ")
for f in unprintable_files :
	print(f)

# sort the files into bins by size
# want 0, 1-1k, 1k-1m, 1m-1g, 1g-1t, 1t+

#import matplotlib.pyplot as plt

# histogram of overall costs
#plt.hist(costs,histtype='step', bins=100)
#plt.savefig('overall_costs.pdf')
#plt.show()

# do histograms for the top 5 most costly groups
#for i in by_group_list[:5] :
#	g=i['grp']
#	gid=i['gid']
#	plt.hist(by_group[gid]['costs'],histtype='step', bins=100, normed=True, label=g)
#plt.legend(loc='upper right')
#plt.title('Cost histograms for 5 most costly groups')
#plt.xlabel('cost')
#plt.ylabel('relative frequency')

# save it as a png
#plt.savefig('group_costs.png')

